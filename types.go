// This file was auto-generated by Fern from our API Definition.

package intrinsic

import (
	json "encoding/json"
	fmt "fmt"
	core "github.com/intrinsic-org/intrinsic-go/core"
)

type DetectionObjectStatus string

const (
	DetectionObjectStatusPending   DetectionObjectStatus = "PENDING"
	DetectionObjectStatusCompleted DetectionObjectStatus = "COMPLETED"
	DetectionObjectStatusFailure   DetectionObjectStatus = "FAILURE"
)

func NewDetectionObjectStatusFromString(s string) (DetectionObjectStatus, error) {
	switch s {
	case "PENDING":
		return DetectionObjectStatusPending, nil
	case "COMPLETED":
		return DetectionObjectStatusCompleted, nil
	case "FAILURE":
		return DetectionObjectStatusFailure, nil
	}
	var t DetectionObjectStatus
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (d DetectionObjectStatus) Ptr() *DetectionObjectStatus {
	return &d
}

type ErrorSchema struct {
	Error *ErrorSchemaError `json:"error,omitempty" url:"error,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ErrorSchema) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorSchema
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorSchema(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorSchema) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorSchemaError struct {
	Type    ErrorSchemaErrorType `json:"type,omitempty" url:"type,omitempty"`
	Message string               `json:"message" url:"message"`
	Code    ErrorSchemaErrorCode `json:"code,omitempty" url:"code,omitempty"`
	Param   *string              `json:"param,omitempty" url:"param,omitempty"`

	_rawJSON json.RawMessage
}

func (e *ErrorSchemaError) UnmarshalJSON(data []byte) error {
	type unmarshaler ErrorSchemaError
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = ErrorSchemaError(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *ErrorSchemaError) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

type ErrorSchemaErrorCode string

const (
	ErrorSchemaErrorCodeFourHundred      ErrorSchemaErrorCode = "400"
	ErrorSchemaErrorCodeFourHundredOne   ErrorSchemaErrorCode = "401"
	ErrorSchemaErrorCodeFourHundredThree ErrorSchemaErrorCode = "403"
	ErrorSchemaErrorCodeFourHundredFour  ErrorSchemaErrorCode = "404"
	ErrorSchemaErrorCodeFiveHundred      ErrorSchemaErrorCode = "500"
	ErrorSchemaErrorCodeFiveHundredOne   ErrorSchemaErrorCode = "501"
)

func NewErrorSchemaErrorCodeFromString(s string) (ErrorSchemaErrorCode, error) {
	switch s {
	case "400":
		return ErrorSchemaErrorCodeFourHundred, nil
	case "401":
		return ErrorSchemaErrorCodeFourHundredOne, nil
	case "403":
		return ErrorSchemaErrorCodeFourHundredThree, nil
	case "404":
		return ErrorSchemaErrorCodeFourHundredFour, nil
	case "500":
		return ErrorSchemaErrorCodeFiveHundred, nil
	case "501":
		return ErrorSchemaErrorCodeFiveHundredOne, nil
	}
	var t ErrorSchemaErrorCode
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorSchemaErrorCode) Ptr() *ErrorSchemaErrorCode {
	return &e
}

type ErrorSchemaErrorType string

const (
	ErrorSchemaErrorTypeInvalidRequestError ErrorSchemaErrorType = "invalid_request_error"
	ErrorSchemaErrorTypeNotEnabledError     ErrorSchemaErrorType = "not_enabled_error"
	ErrorSchemaErrorTypeRateLimitError      ErrorSchemaErrorType = "rate_limit_error"
	ErrorSchemaErrorTypeAuthenticationError ErrorSchemaErrorType = "authentication_error"
	ErrorSchemaErrorTypeNotFoundError       ErrorSchemaErrorType = "not_found_error"
	ErrorSchemaErrorTypeInternalServerError ErrorSchemaErrorType = "internal_server_error"
)

func NewErrorSchemaErrorTypeFromString(s string) (ErrorSchemaErrorType, error) {
	switch s {
	case "invalid_request_error":
		return ErrorSchemaErrorTypeInvalidRequestError, nil
	case "not_enabled_error":
		return ErrorSchemaErrorTypeNotEnabledError, nil
	case "rate_limit_error":
		return ErrorSchemaErrorTypeRateLimitError, nil
	case "authentication_error":
		return ErrorSchemaErrorTypeAuthenticationError, nil
	case "not_found_error":
		return ErrorSchemaErrorTypeNotFoundError, nil
	case "internal_server_error":
		return ErrorSchemaErrorTypeInternalServerError, nil
	}
	var t ErrorSchemaErrorType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e ErrorSchemaErrorType) Ptr() *ErrorSchemaErrorType {
	return &e
}

type EventTypeField struct {
	// Name of the field. Must be unique, and can only contain alphanumeric characters and underscores, and be up to 255 characters
	FieldName string `json:"field_name" url:"field_name"`
	// Type of the field. Can be either strings, numbers, links to JPEG images, or links to video files
	Type EventTypeFieldType `json:"type,omitempty" url:"type,omitempty"`
	// Whether the field is optional or not
	Optional bool `json:"optional" url:"optional"`

	_rawJSON json.RawMessage
}

func (e *EventTypeField) UnmarshalJSON(data []byte) error {
	type unmarshaler EventTypeField
	var value unmarshaler
	if err := json.Unmarshal(data, &value); err != nil {
		return err
	}
	*e = EventTypeField(value)
	e._rawJSON = json.RawMessage(data)
	return nil
}

func (e *EventTypeField) String() string {
	if len(e._rawJSON) > 0 {
		if value, err := core.StringifyJSON(e._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(e); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", e)
}

// Type of the field. Can be either strings, numbers, links to JPEG images, or links to video files
type EventTypeFieldType string

const (
	EventTypeFieldTypeString      EventTypeFieldType = "string"
	EventTypeFieldTypeNumber      EventTypeFieldType = "number"
	EventTypeFieldTypeImageURL    EventTypeFieldType = "image_url"
	EventTypeFieldTypeVideoURL    EventTypeFieldType = "video_url"
	EventTypeFieldTypeTextContent EventTypeFieldType = "text_content"
)

func NewEventTypeFieldTypeFromString(s string) (EventTypeFieldType, error) {
	switch s {
	case "string":
		return EventTypeFieldTypeString, nil
	case "number":
		return EventTypeFieldTypeNumber, nil
	case "image_url":
		return EventTypeFieldTypeImageURL, nil
	case "video_url":
		return EventTypeFieldTypeVideoURL, nil
	case "text_content":
		return EventTypeFieldTypeTextContent, nil
	}
	var t EventTypeFieldType
	return "", fmt.Errorf("%s is not a valid %T", s, t)
}

func (e EventTypeFieldType) Ptr() *EventTypeFieldType {
	return &e
}

type FiredRuleObject struct {
	// ID of the fired rule
	RuleID string `json:"rule_id" url:"rule_id"`
	// Name of the fired rule
	RuleName string `json:"rule_name" url:"rule_name"`
	// Name of the triggered action
	TriggeredActionName string `json:"triggered_action_name" url:"triggered_action_name"`
	object              string

	_rawJSON json.RawMessage
}

func (f *FiredRuleObject) Object() string {
	return f.object
}

func (f *FiredRuleObject) UnmarshalJSON(data []byte) error {
	type embed FiredRuleObject
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*f),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*f = FiredRuleObject(unmarshaler.embed)
	f.object = "fired_rule"
	f._rawJSON = json.RawMessage(data)
	return nil
}

func (f *FiredRuleObject) MarshalJSON() ([]byte, error) {
	type embed FiredRuleObject
	var marshaler = struct {
		embed
		Object string `json:"object"`
	}{
		embed:  embed(*f),
		Object: "fired_rule",
	}
	return json.Marshal(marshaler)
}

func (f *FiredRuleObject) String() string {
	if len(f._rawJSON) > 0 {
		if value, err := core.StringifyJSON(f._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(f); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", f)
}

type ViolatedPolicyObject struct {
	// ID of the policy that was violated
	ID string `json:"id" url:"id"`
	// Version of the policy that was violated
	VersionID *string `json:"version_id,omitempty" url:"version_id,omitempty"`
	// Name of the policy
	Name string `json:"name" url:"name"`
	// Explanation for why policy was violated
	Explanation string `json:"explanation" url:"explanation"`
	object      string

	_rawJSON json.RawMessage
}

func (v *ViolatedPolicyObject) Object() string {
	return v.object
}

func (v *ViolatedPolicyObject) UnmarshalJSON(data []byte) error {
	type embed ViolatedPolicyObject
	var unmarshaler = struct {
		embed
	}{
		embed: embed(*v),
	}
	if err := json.Unmarshal(data, &unmarshaler); err != nil {
		return err
	}
	*v = ViolatedPolicyObject(unmarshaler.embed)
	v.object = "violated_policy"
	v._rawJSON = json.RawMessage(data)
	return nil
}

func (v *ViolatedPolicyObject) MarshalJSON() ([]byte, error) {
	type embed ViolatedPolicyObject
	var marshaler = struct {
		embed
		Object string `json:"object"`
	}{
		embed:  embed(*v),
		Object: "violated_policy",
	}
	return json.Marshal(marshaler)
}

func (v *ViolatedPolicyObject) String() string {
	if len(v._rawJSON) > 0 {
		if value, err := core.StringifyJSON(v._rawJSON); err == nil {
			return value
		}
	}
	if value, err := core.StringifyJSON(v); err == nil {
		return value
	}
	return fmt.Sprintf("%#v", v)
}
